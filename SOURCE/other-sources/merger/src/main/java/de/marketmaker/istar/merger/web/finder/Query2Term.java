/*
 * Query2Term.java
 *
 * Created on 13.08.2008 11:44:31
 *
 * Copyright (c) MARKET MAKER Software AG. All Rights Reserved.
 */
package de.marketmaker.istar.merger.web.finder;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.tree.CommonTree;

import static de.marketmaker.istar.merger.web.finder.Terms.*;

/**
 * Parses a query string and returns the result as a Term object.
 * FinderQueryLexer/FinderQueryParser is generated by antlr3
 * grammar is in istar/merger/web/finder/FinderQuery.g
 *
 * @author Oliver Flege
 * @author Thomas Kiesgen
 */
public class Query2Term {
    private static final char QUOTE = '\'';

    /**
     * convert a string expression into a search Term
     *
     * @param query the string to convert into a search term
     * @return the resulting search term
     * @throws RecognitionException
     */
    public static Term toTerm(String query) throws RecognitionException {
        final FinderQueryLexer lexer = new FinderQueryLexer(new ANTLRStringStream(query));
        final CommonTokenStream tokens = new CommonTokenStream(lexer);
        final FinderQueryParser parser = new FinderQueryParser(tokens);
        final FinderQueryParser.query_return r = parser.query();
        final CommonTree tree = r.getTree();
//        dumpTree(tree, 0);
        return createTerm(tree);
    }

    private static void dumpTree(CommonTree t, int indent) {
        if (t == null) {
            return;
        }
        System.out.println("                     ".substring(0, indent) + t.getText() + ":" + t.getType());
        for (int i = 0; i <  t.getChildCount(); i++) {
            dumpTree((CommonTree) t.getChild(i), indent + 2);
        }
    }

    private static Term createTerm(CommonTree t) {
        if (t == null) {
            return null;
        }

        switch(t.getType()) {
            case FinderQueryParser.AND: {
                final List<Term> terms = createTerms(t);
                return terms == null ? null : (terms.size() == 1 ? terms.get(0) : new AndOp(terms));
            }
            case FinderQueryParser.OR: {
                final List<Term> terms = createTerms(t);
                return terms == null ? null : (terms.size() == 1 ? terms.get(0) : new OrOp(terms));
            }
            case FinderQueryParser.NOT: {
                Term term = createTerm((CommonTree) t.getChild(0));
                return term != null ? new NotOp(term) : null;
            }
            case FinderQueryParser.IN: {
                return new In(getIdentifier(t), getValues(t));
            }
            case FinderQueryParser.REL: {
                return new Relation(getIdentifier(t), getOp(t), getValue(t));
            }
            case FinderQueryParser.IS_NULL: {
                return new Relation(getIdentifier(t), Relation.Op.EQ, null);
            }
            case FinderQueryParser.IS_NOT_NULL: {
                return new Relation(getIdentifier(t), Relation.Op.NEQ, null);
            }
            default: {
                return null;
            }
        }
    }

    private static List<Term> createTerms(CommonTree tree) {
        List<Term> result = new ArrayList<>();
        for (int i = 0; i < tree.getChildCount(); i++) {
            final Term t = createTerm((CommonTree) tree.getChild(i));
            if (t != null) {
                result.add(t);
            }
        }
        return result;
    }

    protected static String getIdentifier(CommonTree t) {
        return t.getChild(0).getText();
    }

    protected static Relation.Op getOp(CommonTree t) {
        return OPS.get(t.getText());
    }

    protected static String getValue(CommonTree t) {
        return unquote(t.getChild(1).getText());
    }

    protected static Set<String> getValues(CommonTree t) {
        Set<String> result = new LinkedHashSet<>();
        for (int i = 1; i < t.getChildCount(); i++) {
            result.add(unquote(t.getChild(i).getText()));
        }
        return result;
    }

    protected static String unquote(String s) {
        if (s == null || s.length() == 0 || s.charAt(0) != QUOTE) {
            return s;
        }
        final int lastCharIndex = s.length() - 1;
        if (s.indexOf(QUOTE, 1) == lastCharIndex) { // no inner "'"
            return s.substring(1, lastCharIndex); // remove encosing "'"
        }
        final StringBuilder sb = new StringBuilder(s.length() - 2);
        for (int i = 1; i < lastCharIndex; i++) {
            if (s.charAt(i) == QUOTE) {
                i++;
            }
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        System.out.println(toTerm("foo = '2012-03-04' && boo IN (5, 8.7) && (h=5.4 and j=7 or k>'9')"));
        System.out.println(toTerm("(country IN ('DE','US') && event_code IN ('boo','far')) || release_date <='2012-02-01'"));
    }
}
